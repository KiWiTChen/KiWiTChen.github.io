[{"content":"认识相关文件 前置工作 点击魔术棒 \u0026ndash;\u0026gt; 点击Listing \u0026ndash;\u0026gt; 将Linker Listing全部勾选（生成.map文件）\n点击魔术棒 \u0026ndash;\u0026gt; 点击Linker \u0026ndash;\u0026gt; 选取Scatter File路径 并 勾选Use Memory Layout from Target Dialog（生成.sct文件）\n（如果不能Edit，取消勾选Use，更改完再勾选回Use）\n再点击User\u0026ndash;\u0026gt; 勾选Run #2\n.map文件 **位置：**位于Listings文件夹，命名为 项目名.map\n节区的跨文件引用 Section Cross References 1 2 stm32f4xx_usart.o(i.USART_DeInit) refers to stm32f4xx_rcc.o(i.RCC_APB1PeriphResetCmd) for RCC_APB1PeriphResetCmd 翻译成中文就是stm32f4xx_usart模块（stm32f4xx_usart.o）中的USART_DeInit函数，\n*引用（调用）*了stm32f4xx_rcc模块（stm32f4xx_rcc.o）中的RCC_APB1PeriphResetCmd函数\n移除未调用模块 Removing Unused input sections from the image 我们以下面这一行为例：\n1 Removing stm32f4xx_adc.o(i.ADC_CommonInit), (48 bytes). 移除了stm32f4xx_adc模块（stm32f4xx_adc.o）中的ADC_CommonInit函数（占用48字节）\n其中该部分最后一行还有所有未调用模块的统计\n1 902 unused section(s) (total 43143 bytes) removed from the image. 映射符号表 Image Symbol Table： 这部分分为两大类 Local Symbols（局部） 和 Global Symbols（全局）\nSymbol Name：符号名称\nValue：存储对应的地址\nOv Type：符号对应的类型 （Number、Section、Thumb Code、Data等）\nSize：存储大小\nObject(Section)：段目标，即所在模块（源文件）\n内存（映射）分布Memory Map of the image Image Entry point ： 指映射入口地址，如果自己重构了start文件，会出现Not specified\n（不影响正常进入程序，但是会WARNING，可以在魔术棒的Linker下的Misc controls 处加入入口地址：\u0026ndash;entry Reset_Handler）。\n没有重写的Image Entry point一般包含下面这些信息：\nExecution Region：执行区域\nLoading Region：加载区域\nBase Addr：存储地址\nSize：存储大小\nType：类型（有Data,Code,Zero,PAD等）\nAttr：属性\nSection Name：段名\nObject：目标\n存储组成大小Image component sizes 主要展示RO、RW、ROM大小，多了debug状态下文件大小。\n.sct文件 .sct文件即为分散加载文件（Linux对应的是.ld文件）\n链接器根据该文件的配置分配各个节区地址，生成分散加载代码，因此我们通过修改该文件可以定制具体节区的存储位置。\n文件解释 一般打开后长这样：\n下面是对代码的解释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 加载域名 起始地址 大小{；加载区域大小 （分号后面是注释） 运行域名 起始地址 大小 ；执行地址 { 中断向量表起始地址， +First表示强制放到首地址 ARM相关库，InRoot$$Sections即ARM库的链接器标号，主要作用COPY RW区到RAM， 然后再RW区后面创建ZI区。 库函数__main函数中有这个段。 它是__main()的一部分。 编译文件RO只读在该区域 编译文件XO只执行在该区域 } 运行内存名字 起始地址 大小 { 编译可读可写，静态区 } } 验证作用 我们不妨试一下修改中断向量表的位置，\n首先关闭Use Memory Layout From Target Dialog，代表用我们自己的.sct来加载\n更改.sct文件，把RESET放入RAM中：\nRebuild后再打开.map文件\n可以看到RESET已经被我们拷贝到了RAM中了。\n重写start文件 1. 栈空间分配 1 2 3 4 5 6 7 Stack_Size EQU 0x00000400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp 2. 堆空间分配 与栈空间分配不同的是Heap需要 __heap_base 与 __heap_limit两个参数进行限制，而栈只需要一个栈指针就可以了（当然都还需要大小)。\n1 2 3 4 5 Heap_Size EQU 0x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit 3. 中断向量表空间分配 对于我们不需要的中断函数，我们都可以直接 DCD 0，因为我们当前重写与验证不需要中断，所以我们只需要 第一行__initial_sp 和 Reset_Handler\n1 2 3 4 __Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler __Vectors_End __Vectors_Size EQU __Vectors_End - __Vectors 具体要写入哪些向量，需要查看对应芯片手册：\n在中断和事件中查看向量表（中文参考手册没有STM32F401RE）\n这里需要注意的是，我们在使用某个STM32产品的时候，不能够只看手册，还要对照官方的start文件的中断向量表中有没有\n对应的中断向量。如果没有，需要在startup中加上！\n4.Reset_Handler函数重写 1 2 3 4 5 6 7 8 9 10 11 12 13 Reset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT mymain IMPORT SystemInit IMPORT myScratterLoad LDR R0, =SystemInit BLX R0 LDR R0, =myScratterLoad BLX R0 BL mymain ;跳转去执行main函数 B . ;原地跳转，即处于循环状态 ENDP ALIGN ;填充字节使地址对齐 Rest_Handler函数还是比较简单的，只需要调用SystemInit和myScratterLoad进行初始化之后就可以进入我们的main函数了\n5.ScratterLoad函数重写 在之前的讲解中，我们其实已经知道了该函数主要执行的是将数据拷贝到它该去的地方，\n在链接完之后，我们可以获得以下参数供我们去操作：\n1 2 3 4 5 6 7 8 9 IMPORT |Image$$RW_IRAM1$$Base| ;从别处导入data段的链接地址 IMPORT |Image$$RW_IRAM1$$Length| ;从别处导入data段的长度 IMPORT |Load$$RW_IRAM1$$Base| ;从别处导入data段的加载地址 IMPORT |Image$$RW_IRAM1$$ZI$$Base| ;从别处导入ZI段的链接地址 IMPORT |Image$$RW_IRAM1$$ZI$$Length|;从别处导入ZI段的长度 复制数据段： 1 2 3 4 5 6 7 8 9 10 ; 复制数据段 LDR R0, = |Load$$RW_IRAM1$$Base| ;将data段的加载地址存入R0寄存器 LDR R1, = |Image$$RW_IRAM1$$Base| ;将data段的链接地址存入R1寄存器 LDR R2, = |Image$$RW_IRAM1$$Length| ;将data段的长度存入R2寄存器 CopyData SUB R2, R2, #4 ;每次复制4个字节的data段数据 LDR R3, [R0, R2] ;把加载地址处的值取出到R3寄存器 STR R3, [R1, R2] ;把取出的值从R3寄存器存入到链接地址 CMP R2, #0 ;将计数和0相比较 BNE CopyData ;如果不相等，跳转到CopyData标签处，相等则往下执行 我们只需要将加载地址的数据复制到链接地址即可,打开我们的.sct文件\n框起来的就是对应的数据，据此可以推断出链接地址。比如因为链接文件规定了RESET在IROM的首地址，所以在.map中可以看到0x08000000加载了RESET。\n清除BSS段： 1 2 3 4 5 6 7 8 9 ; 清除BSS段 LDR R0, = |Image$$RW_IRAM1$$ZI$$Base| ;将bss段的链接地址存入R1寄存器 LDR R1, = |Image$$RW_IRAM1$$ZI$$Length| ;将bss段的长度存入R2寄存器 CleanBss SUB R1, R1, #4 ;每次清除4个字节的bss段数据 MOV R3, #0 ;将0存入r3寄存器 STR R3, [R0, R1] ;把R3寄存器存入到链接地址 CMP R1, #0 ;将计数和0相比较 BNE CleanBss ;如果不相等，跳转到CleanBss标签处，相等则往下执行 与上面类似，只是把0拷贝过去就可以了\n验证 验证工具 使用串口工具，用C语言操控寄存器实现串口通信（不要汇编！不要用库函数！）形如：\n1 2 3 4 5 6 // 阻塞式发送单个字符 void USART1_SendChar(uint8_t ch) { while (!(USART1_SR \u0026amp; (1 \u0026lt;\u0026lt; 7))); // 等待TXE标志置位 USART1_DR = (ch \u0026amp; 0xFF); } 点击魔术棒 \u0026ndash;\u0026gt; Debug \u0026ndash;\u0026gt; Settings \u0026ndash;\u0026gt; Flash Download \u0026ndash;\u0026gt; Erase Full Chip（全片清除)\n验证代码 a. RW-Data ZI-Data Const-Data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026#34;usart.h\u0026#34; int RWData = 1234; int ZIData; const int ConstData = 4321; void mymain(void){ USART1_Init(); uint32_t p; USART1_SendStr(\u0026#34;\\nRW-Data value: \u0026#34;); USART1_SendNumber(RWData, 10); USART1_SendStr(\u0026#34; addr:\u0026#34;); p = (uint32_t)\u0026amp;RWData; USART1_SendNumber(p, 16); USART1_SendStr(\u0026#34;\\nZI-Data value: \u0026#34;); USART1_SendNumber(ZIData, 10); USART1_SendStr(\u0026#34; addr:\u0026#34;); p = (uint32_t)\u0026amp;ZIData; USART1_SendNumber(p, 16); USART1_SendStr(\u0026#34;\\nConst-Data value:\u0026#34;); USART1_SendNumber(ConstData, 10); USART1_SendStr(\u0026#34; addr:\u0026#34;); p = (uint32_t)\u0026amp;ConstData; USART1_SendNumber(p, 16); while(1){ } } 得到结果：\n1 2 3 RW-Data value: 1234 addr:20000000 ZI-Data value: 0 addr:20000004 Const-Data value:4321 addr:800028C 可以看到RW-Data在0x20000000，在RAM中,但是ZI-Data却不是在ZI-Data区域，其实是我们的编译器已经将其进行了初始化，所以还是算到了ZI-Data里面；其中，Const-Data则在Flash中。\nb. 去除myScatterLoad后 我们来去除myScatterLoad函数，还是使用原来的函数，查看结果为：\n1 2 3 RW-Data value: 3758811134 addr:20000000 ZI-Data value: 103643149 addr:20000004 Const-Data value:4321 addr:8000284 可以看到因为我们没有将RW-Data和ZI-Data拷贝到RAM中，所以打印出来的value是乱码；而Const-Data因为在Flash中，则是我们指定的值。\nc. 将RW-Data放到Flash中 更改.sct文件，将RW数据放入IROM中：\n1 2 3 4 5 6 7 8 9 10 11 12 LR_IROM1 0x08000000 0x00080000 { ; load region size_region jia ER_IROM1 0x08000000 0x00080000 { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) .ANY (+XO) .ANY (+RW) } RW_IRAM1 0x20000000 0x00018000 { ; RW data .ANY (+ZI) } } 我们将RW数据放到Flash中（不可以将ZI数据放入到Flash中），因为ZI数据还有Stack和Heap段，如果这两个数据段在Flash中，就不可以正常执行了。\n查看结果为：\n1 2 3 RW-Data value: 1234 addr:8000288 ZI-Data value: 0 addr:800028C Const-Data value:4321 addr:8000284 可以看到我们的数据已经可以正常打印了，而且地址都在Flash中（这个时候需要更改如果）。\n","date":"2025-04-01T00:38:54+08:00","permalink":"https://KiWiTChen.github.io/p/stm32%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%E5%9B%9B%E9%87%8D%E6%9E%84startup%E6%96%87%E4%BB%B6%E5%8F%8A%E9%AA%8C%E8%AF%81/","title":"Stm32学习小记（四）——重构Startup文件及验证"},{"content":"四轴飞行器转接板设计 整体大致的思路：选材-\u0026gt;布局-\u0026gt;绘制-\u0026gt;验证-\u0026gt;调整-\u0026gt;测试\n选材 遥控器和接收机的选择原因：\n对应的接收机支持PPM总线输出，通信抗干扰能力强，同时能实现飞控板单排线输入，简化连线，减轻整机重量； 便于后续解析数据。将接收机的输出端口与 STM32F401RE 主控板的 GPIO 接口连接，便可将遥控器信号转换后的电信号送入 F401 进行处理。 ​\n什么是PPM信号：将多个通道的PWM放到一条数据帧上进行传输，具体可以参考PWM信号与PPM信号辨析\n布局 可以选择单层转接板或者双层转接板，\n双层（上下两层）的优势在于可以充分预留模块的空间，缺点是设计时加大了工作量，不一定能保证整体的美观性；\n单层的优势在于设计较为方便，安装拼接方便，缺点在于各模块空间有限，需要综合考虑布局（三维空间上）。\n我们最后选择了单层转接板，结合意法半导体官网给出的尺寸图纸，大致拟定好了转接板上各个模块的布局\n数据线 我们先规划引脚的复用，在这里有很多种方式，可以使用STM32CubeMX,也可以按照官方引脚图手动分配。为了更贴近实际引脚位置，我们考虑第二种方法。\n协议 引脚号 备注 TIM PB0,PB1,PA6,PA7 通用定时器TIM3 USART PA2,PA3 PA11,PA12 USART2,USART6 蓝牙和串口调试 IIC PB8,PB9 PB10,PB3 IIC1,IIC2 OLED和GY86 电源系统 模块供电 根据 User Manual-Nucleo F401RE 手册以及该开发板的原理图，共有三种供电方式：USB 供电（U5V)、外部供电（E5V）以及外部供电（7V～12V,VIN）。我们选择了外部供电（5V）和USB供电相结合的方案：\n调试时U5V给板子上电，之后开发板通过+5V和+3.3V给各个模块供电。\n组装集成系统时将跳线帽 JP5 移动至左侧两针脚（E5V)；开发板上电后进而给模块供电。\n两种方式本质上只是给STM32开发板的供电方式不同，模块的电源通路并无区别。\n电机供电 分电板 分电板顾名思义就是分电，此外还有稳定电压和降压的功能，通过XT60模块接收来自电池的电流，然后向外输出；\n具体的输出电压有3V3(VCC)、5V（下侧标出）、12V（下侧和侧边）。\n通过焊接方式可以将分电板固定在机架层，方便后续对整个系统的供电\n电调 即：电机调速器\n关于电机和电调详细工作原理的介绍，大家可以参考下面这篇文章：\n有刷电机，无刷电机和电调的原理\n我们只需要知道电调能够更加快速稳定地收发信号，从接收机获得油门信号并控制电机转速变化，总结下来的使用和连接方式就是：\n电调的输入线与稳压电源连接； 电调的输出线与电机连接； 电调的信号线与接收机连接。 调试部分 OLED 在使用GY-86模块获取x,y,z三部分的ACC和GYRO，我们可以封装相应函数，通过程序控制OLED实时展示出相关数据信息，方便后续调试\n串口 在规划引脚时，我们也提前预留好了一个串口数据线USART6，在裸机测试时可以通过USB-TTL模块，在上位机对开发板发送指令（或者从开发板接收指令）\n绘制 第一版使用AD绘制，由于是初次绘制转接板，关于坐标尺寸没有按照官方开发板的规定设计，后面模块位置出现了部分挤占；此外，分电板的转接口封装也与购买时的XT60不同。\n第二版以及第三版我们都采用嘉立创的EDA来进行绘制和修改，立创EDA相比AD使用起来更加灵活，同时也方便后续打板的试错，具体的使用手册大家可以参考官方文档：立创EDA快速入门。\n导入原理图 在AD中将目标文件另存为二进制文件，然后在立创EDA中导入，之后再更新封装，绘制PCB图，使用到的封装大致如下：\n个性化设计 板框 如果对板框形状有要求的话，可以导入DXF文件，双击导入层，可以选择导入的图层\nLogo 支持图片格式有：SVGZ、SVG、PNG、PIP、JPG、PJPEG、JPEG、JFIF格式\n成品 经过修改调整，我们组最终的转接板大致如下：\n得到的PCB文件生成Gerber格式的文件，可以在嘉立创平台免费下单打样：领取免费券-\u0026gt;上传PCB文件-\u0026gt;选择相应信息下单。\n验证 电源 在得到成品PCB板之后，上电测试之前可以使用万用表简单检测一下电路VCC、GND等是否正确连接。先将万用表调至通断档，短接表头听到“滴滴”声响表明万用表能正常工作；然后依次测量VCC两端、GND两端以及VCC+GND，接通时能听到“滴滴\u0026rsquo;\u0026lsquo;声，不接通时无声响即检测通过。\n此外万用表还可以用来测试电阻、交流电压、电流、温度等数据。\n理论上电路网络设计合理，且PCB绘制后通过了DRC规则检查的话，PCB板的电源应该没有问题，不过为了不烧坏开发板，还是可以检测一下。\n信号 示波器的使用：\n将程序烧录至开发板，启动示波器，钳子一端接板上GND接口，另一端连接目标GPIO口（即发出PWM信号的引脚），可以使用Autoset功能自动设置方波展示，也可以手动调节显示波长和振幅等信息；\n如上图测得频率1/Δx:185.2Hz,最大电压Ma3.32V,最小Mi-120mV,占空比+D10.1%等。\n","date":"2025-03-30T15:59:21+08:00","permalink":"https://KiWiTChen.github.io/p/%E5%9B%9B%E8%BD%B4%E9%A3%9E%E8%A1%8C%E5%99%A8%E7%BB%BC%E5%90%88%E8%AE%BE%E8%AE%A1%E4%B9%8B%E8%BD%AC%E6%8E%A5%E6%9D%BF%E7%BB%98%E5%88%B6/","title":"四轴飞行器综合设计之转接板绘制"},{"content":"启动模式 stm32有多种启动模式，以STM32F4XX为例，如下图所示：\n并非所有芯片都适用于这个表格，不同型号具体启动方式请参考对应手册,官方也有Bootloader介绍文档可以查看。\n第一种启动方式 最常用的用户FLASH启动，正常工作就在这种模式下，STM32的FLASH可以擦除10万次，所以不用担心芯片哪天会被擦爆。\n第二种启动方式 系统存储器启动方式，使用串口下载程序或者使用USB-DFU模式下载程序，不建议使用这种，速度比较慢。STM32 中自带的BootLoader就是在这种启动方式中，如果出现程序硬件错误的话可以切换BOOT0/1到该模式下重新烧写Flash即可恢复正常。\n第三种启动方式 STM32内嵌的SRAM启动，一般该模式用于调试。 用J-Link在线仿真，则是下载到SRAM中。\n启动文件 内存分布 STM32的数据在物理上分别储存在RAM和Flash中。\nRAM可读可写，掉电清零。Flash可读可写，但是读写时间很长，能掉电储存，并且一般空间比RAM大很多。\n下图是STM32F4XX的Memory Map,可以看到，其FLASH起始地址为0x0800 0000,大小为512KB\n那么FLASH和RAM主要存储哪些数据呢？这里又涉及到了６个储存数据段和３种储存属性区的概念，可以参考这篇博客。\n６个储存数据段 data 数据段，储存已初始化的，且初始化不为0的全局变量和静态变量。\nbss Block Started by Symbol。储存未初始化的，或初始化为0的全局变量和静态变量。\n1 int c;//这里c会被放入BSS区域，后续会对其赋初始值为0 text 用户的代码段，储存程序代码。\nconstdata 储存只读常量。\nheap 堆，存放进程运行中被动态分配的内存段。其可用大小定义在启动文件startup_stm32fxx.s中，由程序员使用malloc()和free()函数进行分配和释放。\nstack 栈，其大小定义在启动文件startup_stm32fxx.s中，由系统自动分配和释放。可存放局部变量、函数的参数和返回值，中断发生时能保存现场。但是static声明的局部静态变量不储存在栈中，而是放在data数据段。\n3种储存属性区 RO(Read Only) 烧写到Flash中，可以长久保存。text代码段和constdata都属于RO。由于需要掉电储存，RO里也保存了一份data的数据。\nRW(Read Write) 储存在RAM中。data属于此区。上电时单片机会将Flash中保存的data类型数据复制到RAM中，以供读写使用。\nZI(Zero Init) 零初始化区，同样储存在RAM里。系统上电时会把此区域的数据进行0初始化。bss，heap，stack均属于这个区域。\n小结 链接时记录bss段大小，装载（后续会提到）时分配空间\nFLASH：Code + RO-Data + RW-Data（运行时搬运到RAM里面）\nSRAM： RW-Data + ZI-Data\n代码详解 打开startup_stm32f40_41xxx.s文件，我们可以查看详细启动文件代码。\n1 2 3 4 5 Stack_Size EQU 0x400 AREA STACK, NOINIT, READWRITE, ALIGN=3 Stack_Mem SPACE Stack_Size __initial_sp 分配了一段大小为1KB的栈空间，段名STACK，可读写，ALIGN=3表示2^3=8字节对齐，\u0026quot;_ _initial_sp\u0026quot;紧挨着栈的结束地址，由于栈是从高往低生长，所以\u0026quot;__initial_sp\u0026quot;的位置就是栈顶。\n1 2 3 4 5 6 Heap_Size EQU 0x200 AREA HEAP, NOINIT, READWRITE, ALIGN=3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit 分配了一段大小为512字节的堆空间，段名HEAP，可读可写，8字节对齐，__heap_base和__heap_limit分别是堆的起始地址和结束地址。\n1 2 PRESERVE8 THUMB 指定当前文件的堆栈按照8字节对齐，后面指令兼容16位的Thumb指令。Cortex-M内核实际使用的是Thumb-2指令集，将16位与32位指令混合使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 AREA RESET, DATA, READONLY EXPORT __Vectors EXPORT __Vectors_End EXPORT __Vectors_Size __Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler DCD HardFault_Handler ; Hard Fault Handler DCD MemManage_Handler ; MPU Fault Handler DCD BusFault_Handler ; Bus Fault Handler DCD UsageFault_Handler ; Usage Fault Handler DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD 0 ; Reserved DCD SVC_Handler ; SVCall Handler DCD DebugMon_Handler ; Debug Monitor Handler DCD 0 ; Reserved DCD PendSV_Handler ; PendSV Handler DCD SysTick_Handler ; SysTick Handler ; External Interrupts DCD WWDG_IRQHandler ; Window WatchDog DCD PVD_IRQHandler ; PVD through EXTI Line detection ………… DCD 0 ; Reserved DCD SPI4_IRQHandler ; SPI4 __Vectors_End __Vectors_Size EQU __Vectors_End - __Vectors 定义了一个数据段，名为DATA，仅可读。\n上文为堆栈分配的空间均位于SRAM中，不占用代码空间，从这个数据段开始才是stm32代码空间的起始位置，先定义并初始化了栈顶位置（_ _initial_sp）以及15个内核异常处理函数的入口地址，接下来是外部中断，最后用结束地址减去开始地址得到__Vectors_Size即本数据段的大小。\n1 2 3 4 5 6 7 8 9 10 Reset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT SystemInit IMPORT __main LDR R0, =SystemInit BLX R0 LDR R0, =__main BX R0 ENDP reset_handler即复位程序的实际执行代码，上电或是复位都会先从这里开始执行然后进入main函数，具体的执行过程暂且按下不表，我们继续看启动文件的后续内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 NMI_Handler PROC EXPORT NMI_Handler [WEAK] B . ENDP HardFault_Handler\\ PROC EXPORT HardFault_Handler [WEAK] B . ENDP ………… SysTick_Handler PROC EXPORT SysTick_Handler [WEAK] B . ENDP Default_Handler PROC EXPORT WWDG_IRQHandler [WEAK] EXPORT PVD_IRQHandler [WEAK] EXPORT TAMP_STAMP_IRQHandler [WEAK] ………… EXPORT SPI4_IRQHandler [WEAK] WWDG_IRQHandler PVD_IRQHandler TAMP_STAMP_IRQHandler ………… SPI4_IRQHandler B . ENDP ALIGN 将除了reset_handler外的内核异常都分别写成无限循环（B .）的弱函数，外部中断也是如此，只是函数起始位置都是同一个地址。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 IF :DEF:__MICROLIB EXPORT __initial_sp EXPORT __heap_base EXPORT __heap_limit ELSE IMPORT __use_two_region_memory EXPORT __user_initial_stackheap __user_initial_stackheap LDR R0, = Heap_Mem LDR R1, =(Stack_Mem + Stack_Size) LDR R2, = (Heap_Mem + Heap_Size) LDR R3, = Stack_Mem BX LR ALIGN ENDIF END 如果使用了microlib则将栈顶地址和堆的起始、结束地址export出去，microlib会进行堆栈初始化的操作，若是没有使用，则堆栈初始化时会使用__user_initial_stackheap函数。\n启动流程 地址映射 STM32的代码是烧写到flash中的，通过查询手册可知，STM32F401XX的flash的起始地址是0x08000000；当然通过KEIL已配置好的工程也能查看flash信息：\n但是Cortex-M内核规定上电后必须从0x00000000的位置开始执行，这就需要一个地址映射的操作，不论stm32的启动模式是本文开头说的哪一种，都会将该启动区域的代码映射到0x00000000的位置，进入keil的调试模式打开memory窗口，输入查看0x00000000和0x08000000：\n我们可以发现数据是完全相同的。\n通过地址映射机制，同一份代码可通过硬件配置在不同启动模式下运行，用户不需要关心物理地址的具体位置，只需使用链接脚本将代码和数据分配到正确的地址区域。例如，中断向量表默认放在Flash的起始位置，但通过VTOR寄存器可以重定位到SRAM，这种灵活性在调试或需要动态加载代码时非常有用，从而提高了开发效率\n硬件自动为MSP和PC赋值,开始执行reset_handler 分析启动代码时我们提到过，从DATA段开始才是代码段的起始位置，那么0x08000000作为起始地址的4字节空间存储的就是__initial_sp的地址，即栈顶地址，上电或复位后，硬件会自动将该地址赋给MSP，即主栈指针，随后将0x08000004作为起始地址的4字节空间内容，也就是reset_handler函数入口地址赋给PC。\n此时程序会立刻去执行reset_handler，让我们回过头来看看reset_handler中做了些什么：\n1 2 3 4 5 6 7 8 9 10 Reset_Handler PROC EXPORT Reset_Handler [WEAK] IMPORT SystemInit IMPORT __main LDR R0, =SystemInit BLX R0 LDR R0, =__main BX R0 ENDP 可以看到，reset_handler中执行了两个程序，SystemInit和**__main**。\nSystem_Init 不同型号芯片的默认systeminit函数有所区别，内容往往是初始化时钟、FPU等。\n用户没有重写\u0026quot;_ _main\u0026quot;的情况下，该函数并不在库文件中，而是由armlink创建，如果想要在keil调试的时候查看__main的具体执行过程，需要在BX R0指令运行前点击汇编代码的内容框，再继续单步执行，则可以看到 _ _main的汇编代码，否则会直接跳进main函数。\n__main _ _main中调用了 _ _scatterload和 _ _rt_entry两个函数：\n__scatterload(分散加载) 默认的__scatterload函数做了两件事：\n1.将ZI段数据全部初始化为0\n2.将“非根区域”的数据从加载域复制到执行域（将可读可写的数据搬运到RAM）\n在keil工程目录下的${工程名}.sct文件中可以查看加载域和执行域的地址以及数据存储位置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; ************************************************************* ; *** Scatter-Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x08000000 0x00080000 { ; load region size_region ER_IROM1 0x08000000 0x00080000 { ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) .ANY (+XO) } RW_IRAM1 0x20000000 0x00018000 { ; RW data .ANY (+RW +ZI) } } 可以看到，加载域的地址就是flash的地址，且只读的数据（RO、XO）放在flash（0x08000000\u0026ndash;0x08080000）中，可读可写的数据（RW、ZI）放在RAM（0x20000000\u0026ndash;0x20018000）中。\n__rt_entry _ _scatterload函数执行完后接着调用 _ _rt_entry， _ _rt_entry又调用了如下函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 _platfoem_pre_stackheap_init __user_setup_stackheap **or** setup the Stack Pointer(SP) by another method _platfoem_post_stackheap_init __rt_lib_init _platfoem_post_lib_init main() exit() 其中__user_setup_stackheap就是启动文件末尾的函数，如果没有使用microlib的话就会调用它。\n__rt_entry负责初始化堆栈以及C语言库子系统，即C语言代码运行所必需的环境，随后万事俱备，就可以跳入main函数执行C语言代码了。\n当然，如果没有在main函数中写死循环的话，main函数执行完了后会到达exit退出程序。\n总结 总结一下，芯片上电第一件事是把代码空间的第一行，即栈顶指针赋给msp，随后将第二行reset_handler的入口地址赋给pc，使程序立刻跳转去执行reset_handler，在reset_handler中先初始化时钟、FPU等硬件相关配置（具体内容根据芯片型号有所不同），再初始化ZI段，将代码和数据从加载域搬运到执行域，随后初始化堆栈和C语言库子系统，使得C语言代码能够正常运行，最后跳入main函数执行用户编写的C程序。\n","date":"2025-03-24T00:31:15+08:00","permalink":"https://KiWiTChen.github.io/p/stm32%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%E4%B8%89stm32_cortex-m%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/","title":"Stm32学习小记（三）——STM32_Cortex M启动流程详解"},{"content":"任务目标 嵌⼊式操作系统是介于⽤⼾程序和硬件间，操作系统对⽤⼾隐藏了硬件细节，⽤⼾只需要根据操作系统提供的接⼝便能对各种硬件资源进⾏访问。\n这里我们以μC/OS_II为例，通过ARMKeil重构μC/OS_II代码，为后续的完整移植做铺垫；\n了解操作系统的基本原理，了解任务创建，栈的生成，就绪队列，中断，信号量等基本概念。\n系统结构 内核架构 上图是μC/OS_II的内核架构，据此我们可以参考官方源码确定重构文件结构大致如下：\n​\tProject\u0026ndash;|Core\u0026ndash;|os_core.c\n​\t|os_task.c\u0026hellip;\n​\t|Cfg \u0026ndash;|os_cfg.h\n​\t|app_cfg.h\n​\t|Port \u0026ndash;|os_cpu.h\n​\t|os_cpu_c.h\n​\t|os_cpu_a.s\n​\t|Prj //Keil相关编译文件\n​\t|User //用户自定义函数以及main\n模块介绍 Core层（核心，一般不做修改） os_core.c：负责操作系统内核的初始化和核⼼功能的实现，包括任务调度器的初始化和空闲任务的创建。 os_task.c：包含任务管理相关的函数，如任务的创建、删除和任务控制块（TCB）的操作。 os_flag.c：实现事件标志组功能，⽤于任务间的同步和通信。 os_mem.c：提供内存管理功能，包括内存块的分配和释放。 os_tmr.c：实现软件定时器功能，允许在指定时间后执⾏特定操作。 os_mutex.c：提供互斥信号量功能，⽤于保护共享资源，防⽌同时访问导致的数据不⼀致。 os_sem.c：uC/OS II中的信号量（Semaphore）功能在任务间的同步和互斥上起着重要作⽤。这个⽂件实现了信号量的接⼝函数 os_mbox.c: 邮箱（Mailbox）是uC/OS II⽤于任务间消息传递的机制之⼀。这个⽂件实现了邮箱功能的接⼝函数。 os_q.c：队列（Queue）也是任务间通信常⽤的⽅式之⼀，这个⽂件实现了队列的接⼝函数。 ucos_ii.c：这个源⽂件包含了uC/OS II内核的核⼼功能实现，如操作系统初始化、任务调度算法、时钟节拍处理、中断管理、任务创建与删除、事件标志组、信号量、互斥量、邮箱和队列等操作的代码。它是uC/OS II操作系统运⾏的基础，实现了多任务环境下的同步与通信机制。 ucos_ii.h：这个头⽂件包含了uC/OS II内核中使⽤的各种数据结构的定义，如任务、事件、链表、信号量等，以及函数声明。 Port层（移植层，与硬件平台相关） ⭐ Ports ⽂件夹中的⽂件包含了针对不同处理器平台的移植代码。每个处理器平台都有不同的硬件架构和操作系统接⼝，因此需要根据处理器的特点进⾏移植，以确保 uC/OS II 内核可以在特定处理器上正确地运⾏。\nSTM32F401RET6是ARMV7架构的芯片，所以我们在官方的文件中能看到大致有这么几个文件：\nos_cpu.h：定义与处理器架构相关的数据类型和宏，确保操作系统能够在特定的 CPU 上运⾏。\nos_cpu_a.asm：包含与处理器架构相关的汇编代码，如上下⽂切换和中断处理等底层操作。\nos_cpu_c.c：实现与处理器架构相关的 C 语⾔函数，如任务上下⽂初始化等。\nCfg层（配置文件，决定任务、堆栈、功能） os_cfg.h：⽤于配置操作系统的功能和特性，如任务数量、堆栈⼤⼩、是否启⽤某些功能等。 app cfg.h：包含应⽤程序所需的头⽂件，确保编译器能够找到所有必要的声明和定义。 项目创建 新建⼀个总工程⽂件夹，并在⽂件夹下⾯再新增⽂件夹Port、Cfg、Core、Prj，在Core⽂件夹中导⼊官⽹所给的⽂件。\n打开keil5，把它们导入到项目中。选择project-\u0026gt;new uversionproject,项目文件放至Prj文件夹中，然后选好芯片型号：STM32F401RETx\n右键单击target1-addgroup新建文件夹，并重命名为Core、Port和Cfg，右键单击文件夹，addexistingfilestogroup‘xxx’添加文件。\n添加头文件路径。打开魔术棒，在C/C++和Asm里的IncludePath中写入C程序和汇编文件的路径。\n报错解决 错误类型1：缺少⽂件或找不到⽂件 解决方式：创建对应文件，暂时“骗”过编译器\n1 .\\Core\\ucos_ii.h(45): error: #5: cannot open source input file \u0026#34;app_cfg.h\u0026#34;: No such file or directory 这个报错信息提⽰我们缺少app_cfg.h⽂件，于是我们先建⽴⼀个空的app_cfg.h⽂件在Cfg⽂件夹中。\n同理添加os_cfg.h、os_cpu.h\n错误类型2：缺少相应的数据类型的定义和函数的声明。 解决方式：在os_cpu.h⽂件中添加相应的定义\n1 .\\Core\\ucos_ii.h(372): error: #20: identifier \u0026#34;INT8U\u0026#34; is undefined 为什么需要定义不同的变量类型INT8U,INT16U等？\n由于signed int，unsigned int等原⽣类型时，其实际位数取决于处理器。⽐如在16位系统中int通常为16位，⽽在32/64位系统中，int通常为32位。这会导致移植时不同平台时产⽣数据溢出等情况。\n自定义数据类型，通过typedef明确定义数据类型的位数，保证了跨平台的⼀致性。\n下表是对于μC/OS_II中数据类型的定义参考：\n所以选择在os_cpu.h文件中定义相关数据类型：\n1 2 3 4 5 6 7 8 9 10 11 12 //数据类型 typedef unsigned char BOOLEAN; // 定义布尔类型 typedef unsigned char INT8U; // ⽆符号8位整数 typedef signed char INT8S; // 有符号8位整数 typedef unsigned short INT16U; // ⽆符号16位整数 typedef signed short INT16S; // 有符号16位整数 typedef unsigned int INT32U; // ⽆符号32位整数 typedef signed int INT32S; // 有符号32位整数 typedef float FP32; // 单精度浮点数 typedef double FP64; // 双精度浮点数 typedef unsigned int OS_STK; // 每个栈条⽬为32位宽 typedef unsigned int OS_CPU_SR;// 定义CPU状态寄存器的⼤⼩（PSR = 32位） 错误类型3：os_cfg.h中缺少相应功能定义。 解决方式：参考官方源码中cfg文件，在os_cfg.h⽂件中添加相应的宏定义\n1 .\\ucos\\ucos_ii.h(1482) : error : #35 : #error directive:\u0026#34;OS_CFG.H,MissingOS_FLAG_EN: Enable(1) or Disable (0) code generation for Event Flags 我们在os_cfg.h文件中暂时对相应参数配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 /* ---------------------- MISCELLANEOUS ----------------------- */ #define OS_APP_HOOKS_EN 1u /* Application-defined hooks arecalled from the uC/OS-II hooks */ #define OS_ARG_CHK_EN 1u /* Enable (1) or Disable (0) argumentchecking */ #define OS_CPU_HOOKS_EN 1u /* uC/OS-II hooks are found in theprocessor port files */ #define OS_DEBUG_EN 0u /* Enable(1) debug variables*/ #define OS_EVENT_MULTI_EN 1u /* Include code for OSEventPendMulti()*/ #define OS_EVENT_NAME_EN 1u /* Enable names for Sem, Mutex, Mboxand Q */ #define OS_LOWEST_PRIO 63u /* Defines the lowest priority thatcan be assigned ... */ /* ... MUST NEVER be higher than 254!*/ #define OS_MAX_EVENTS 10u /* Max. number of event control blocksin your application */ #define OS_MAX_FLAGS 5u /* Max. number of Event Flag Groupsin your application */ #define OS_MAX_MEM_PART 5u /* Max. number of memory partitions*/ #define OS_MAX_QS 4u /* Max. number of queue control blocksin your application */ #define OS_MAX_TASKS 20u /* Max. number of tasks in yourapplication, MUST be \u0026gt;= 2 */ #define OS_SCHED_LOCK_EN 1u /* Include code for OSSchedLock() andOSSchedUnlock() */ #define OS_TICK_STEP_EN 1u /* Enable tick stepping feature foruC/OS-View */ #define OS_TICKS_PER_SEC 100u /* Set the number of ticks in onesecond */ #define OS_TLS_TBL_SIZE 0u /* Size of Thread-Local Storage Table*/ /* --------------------- TASK STACK SIZE ---------------------- */ #define OS_TASK_TMR_STK_SIZE 128u /* Timer task stack size (# ofOS_STK wide entries) */ #define OS_TASK_STAT_STK_SIZE 128u /* Statistics task stack size (# ofOS_STK wide entries) */ #define OS_TASK_IDLE_STK_SIZE 128u /* Idle task stack size (# ofOS_STK wide entries) */ /* --------------------- TASK MANAGEMENT ---------------------- */ #define OS_TASK_CHANGE_PRIO_EN 1u /* Include code forOSTaskChangePrio() */ #define OS_TASK_CREATE_EN 1u /* Include code for OSTaskCreate()*/ #define OS_TASK_CREATE_EXT_EN 1u /* Include code forOSTaskCreateExt() */ #define OS_TASK_DEL_EN 1u /* Include code for OSTaskDel()*/ #define OS_TASK_NAME_EN 1u /* Enable task names*/ #define OS_TASK_PROFILE_EN 1u /* Include variables in OS_TCB forprofiling */ #define OS_TASK_QUERY_EN 1u /* Include code for OSTaskQuery()*/ #define OS_TASK_REG_TBL_SIZE 1u /* Size of task variables array(#of INT32U entries) */ #define OS_TASK_STAT_EN 1u /* Enable (1) or Disable(0) thestatistics task */ #define OS_TASK_STAT_STK_CHK_EN 1u /* Check task stacks fromstatistic task */ #define OS_TASK_SUSPEND_EN 1u /* Include code forOSTaskSuspend() and OSTaskResume() */ #define OS_TASK_SW_HOOK_EN 1u /* Include code for OSTaskSwHook()*/ /* ----------------------- EVENT FLAGS ------------------------ */ #define OS_FLAG_EN 1u /* Enable (1) or Disable (0) codegeneration for EVENT FLAGS */ #define OS_FLAG_ACCEPT_EN 1u /* Include code for OSFlagAccept()*/ #define OS_FLAG_DEL_EN 1u /* Include code for OSFlagDel()*/ #define OS_FLAG_NAME_EN 1u /* Enable names for event flaggroup */ #define OS_FLAG_QUERY_EN 1u /* Include code for OSFlagQuery()*/ #define OS_FLAG_WAIT_CLR_EN 1u /* Include code for Wait on ClearEVENT FLAGS */ #define OS_FLAGS_NBITS 16u /* Size in #bits of OS_FLAGS data type(8, 16 or 32) */ /* -------------------- MESSAGE MAILBOXES --------------------- */ #define OS_MBOX_EN 1u /* Enable (1) or Disable (0) codegeneration for MAILBOXES */ #define OS_MBOX_ACCEPT_EN 1u /* Include code for OSMboxAccept()*/ #define OS_MBOX_DEL_EN 1u /* Include code for OSMboxDel()*/ #define OS_MBOX_PEND_ABORT_EN 1u /* Include code forOSMboxPendAbort() */ #define OS_MBOX_POST_EN 1u /* Include code for OSMboxPost()*/ #define OS_MBOX_POST_OPT_EN 1u /* Include code forOSMboxPostOpt() */ #define OS_MBOX_QUERY_EN 1u /* Include code for OSMboxQuery()*/ /* --------------------- MEMORY MANAGEMENT -------------------- */ #define OS_MEM_EN 1u /* Enable (1) or Disable (0) codegeneration for MEMORY MANAGER */ #define OS_MEM_NAME_EN 1u /* Enable memory partition names*/ #define OS_MEM_QUERY_EN 1u /* Include code for OSMemQuery()*/ /* ---------------- MUTUAL EXCLUSION SEMAPHORES --------------- */ #define OS_MUTEX_EN 1u /* Enable (1) or Disable (0) codegeneration for MUTEX */ #define OS_MUTEX_ACCEPT_EN 1u /* Include code forOSMutexAccept() */ #define OS_MUTEX_DEL_EN 1u /* Include code for OSMutexDel()*/ #define OS_MUTEX_QUERY_EN 1u /* Include code for OSMutexQuery()*/ /* ---------------------- MESSAGE QUEUES ---------------------- */ #define OS_Q_EN 1u /* Enable (1) or Disable (0) codegeneration for QUEUES */ #define OS_Q_ACCEPT_EN 1u /* Include code for OSQAccept()*/ #define OS_Q_DEL_EN 1u /* Include code for OSQDel()*/ #define OS_Q_FLUSH_EN 1u /* Include code for OSQFlush()*/ #define OS_Q_PEND_ABORT_EN 1u /* Include code for OSQPendAbort()*/ #define OS_Q_POST_EN 1u /* Include code for OSQPost()*/ #define OS_Q_POST_FRONT_EN 1u /* Include code for OSQPostFront()*/ #define OS_Q_POST_OPT_EN 1u /* Include code for OSQPostOpt()*/ #define OS_Q_QUERY_EN 1u /* Include code for OSQQuery()*/ /* ------------------------ SEMAPHORES ------------------------ */ #define OS_SEM_EN 1u /* Enable (1) or Disable (0) codegeneration for SEMAPHORES */ #define OS_SEM_ACCEPT_EN 1u /* Include code for OSSemAccept()*/ #define OS_SEM_DEL_EN 1u /* Include code for OSSemDel()*/ #define OS_SEM_PEND_ABORT_EN 1u /* Include code forOSSemPendAbort() */ #define OS_SEM_QUERY_EN 1u /* Include code for OSSemQuery()*/ #define OS_SEM_SET_EN 1u /* Include code for OSSemSet()*/ /* --------------------- TIME MANAGEMENT ---------------------- */ #define OS_TIME_DLY_HMSM_EN 1u /* Include code forOSTimeDlyHMSM() */ #define OS_TIME_DLY_RESUME_EN 1u /* Include code forOSTimeDlyResume() */ #define OS_TIME_GET_SET_EN 1u /* Include code for OSTimeGet()and OSTimeSet() */ #define OS_TIME_TICK_HOOK_EN 1u /* Include code forOSTimeTickHook() */ /* --------------------- TIMER MANAGEMENT --------------------- */ #define OS_TMR_EN 0u /* Enable (1) or Disable (0) codegeneration for TIMERS */ #define OS_TMR_CFG_MAX 16u /* Maximum number of timers*/ #define OS_TMR_CFG_NAME_EN 1u /* Determine timer names*/ #define OS_TMR_CFG_WHEEL_SIZE 7u /* Size of timer wheel (#Spokes)*/ #define OS_TMR_CFG_TICKS_PER_SEC 10u /* Rate at which timer managementtask runs (Hz) */ /* ---------------------- TRACE RECORDER ---------------------- */ #define OS_TRACE_EN 0u /* Enable (1) or Disable (0) uC/OS-IITrace instrumentation */ #define OS_TRACE_API_ENTER_EN 0u /* Enable (1) or Disable (0) uC/OS-IITrace API enter instrum. */ #define OS_TRACE_API_EXIT_EN 0u /* Enable (1) or Disable (0) uC/OS-IITrace API exit instrum. */ 在后续的学习中，可以把相关的功能给禁⽤，注意部分参数的取值范围，若设定的参数不在范围内则会报错。\n1 #define OS_TMR_EN 0u /* Enable (1) or Disable (0) code generation for TIMERS */ 将 OS_TMR_EN 设置为 0u 会使 uC/OS-II 禁⽤定时器功能的代码⽣成。STM32F401具有多个定时器Timer，可以满⾜定时中断、PWM输出、输⼊捕获、输出⽐较等功能，也可以使⽤Systick（SysTick是 Cortex-M 内核中的⼀个系统定时器，属于内核的⼀部分）\n1 #define OS_DEBUG_EN 0u /* Enable(1) debug variables*/ OS_DEBUG这个功能在后续的操作中没什么⽤但是会产⽣报错，所以我们也将这个功能给关闭。\n错误类型4：链接时重复定义 解决方法：搜索重复定义的文件，调整include path\n1 .\\Objects\\projects.axf: Error: L6200E: Symbol OSEventNameGet multiply defined (by ucos_ii.o and os_core.o). 上述报错说的是OSEventNameGet在两个文件ucos_ii.o and os_core.o中被重复定义；\n这两个.o文件都是编译器编译同名.c文件生成的对象（object）文件。\n这里一般的思路是借助CTRL+F搜索对应变量，定位重复部分，然后调整.h或者.c的“#include \u0026lsquo;xxx\u0026rsquo; \u0026ldquo;部分。\n为什么链接阶段报错而不是编译？ ——简单理解为预处理粘贴include部分的代码块，编译不报错，但是链接时会发现”重复定义“\n可以参考《深入理解计算机系统》这本书，或者这篇博客，\n预处理器主要将项目代码进行处理，删除注释、#include、展开宏定义等； 编译器则是我们熟悉的词法分析、语法分析、语义分析等过程得到.s文件； 经过汇编器处理后汇编得到.o文件; 之后链接器会检查所有⽬标⽂件和库⽂件中的符号定义和引⽤； 最终生成可执行程序。 具体解决\n在重构项目中，ucos_ii.c文件”粘贴“了多个os_xxx.c文件中的内容，而项目中os_xxx.c也会被编译，最后在链接时发现重定义；\n所以我们只需要右键core，点击魔术棒，关闭此部分的编译包含。\n错误类型5：缺少启动⽂件导致链接失败 解决方法：导入对应启动文件.s\n1 .\\Objects\\ucosii.axf: Error: L6320W: Ignoring --entry command.Cannot find argument \u0026#39;Reset_Handler\u0026#39; //截取了一条 缺少了启动文件，程序找不到执行入口以及中断向量表等，所以也会报错，后续我们还会对启动文件进行进一步分析；\n这里只需要新建一个Startup文件夹，导入startup_stm32f40_41xxx.s。\n错误类型6：os_cpu_.c中hook函数 解决方法：暂时空定义函数，后续补充完善\n1 .\\Objects\\test.axf: Error: L6218E: Undefined symbol OSCtxSw (referred from os_core.o). 什么是Hook函数？ 钩子函数是uC/OS-II内核在特定操作（如任务创建、删除、切换等）前后调用的空函数（默认为空实现）。开发者通过重写这些函数，可以在不修改内核源码的情况下扩展功能。常见用途包括：\n调试与监控：记录任务创建/删除时间、堆栈使用情况等。 资源管理：在任务创建时初始化自定义数据结构或外设。 性能分析：统计任务执行时间或上下文切换次数。 安全检查：验证任务参数的合法性。 以OSTaskCreateHook为例，它在任务创建后被调用，允许开发者在任务首次运行前执行自定义逻辑。\n简单来讲就是获取操作系统的相关状态\n具体解决\n我们需要新建⼀个os_cpu_c.c⽂件和⼀个os_cpu_a.s⽂件，在其中补充缺少的函数实现，⽬前我们不需要补全具体的函数实现细节，只需要写⼀个空定义来骗过编译器。\n在os_cpu_c.c⽂件中，我们定义空的系统初始化函数、钩⼦函数、cpu异常栈基地址和这是内核可⽤\n的优先级边界。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026#34;os_cpu.h\u0026#34; // 系统初始化函数，通常⽤于设置硬件相关的设置 void SystemInit(){} // 定义空的钩⼦函数 void OSInitHookBegin(){} void OSInitHookEnd(){} void OSTCBInitHook(){} void OSTaskCreateHook(){} void OSTaskIdleHook(){} void OSTaskReturnHook(){} void OSTaskSwHook(){} // 任务堆栈初始化函数，为新任务分配堆栈空间 OS_STK *OSTaskStkInit(void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT16U opt){ return ptos; } // 定义⼀个空的CPU异常栈基地址 void OS_CPU_ExceptStkBase(){} // 设置内核可⽤的优先级边界 void OS_KA_BASEPRI_Boundary(){} 错误类型7：中断、恢复与切换实现函数 解决方法：编写汇编函数确定相关逻辑\n为什么要使用汇编？ 在os_cpu_a.s⽂件中，实现的是与处理器相关的函数,这⼀部分的函数涉及CPU 特权寄存器的访问、寄存器状态的保存与恢复，以及任务上下⽂切换。\n这些操作需要对CPU 体系结构和指令集进⾏精确控制，⽽⾼级语⾔（如 C）⽆法不提供直接读写特定硬件寄存器（如中断寄存器PRIMASK、堆栈PSP、任务控制块TCB）的机制，也难以确保任务切换的精确性和⾼效性。\n具体解决\n创建os_cpu_a.s文件，定义相关函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 EXPORT OS_CPU_SR_Save EXPORT OS_CPU_SR_Restore EXPORT OSCtxSw EXPORT OSIntCtxSw EXPORT OSStartHighRdy EXPORT OS_CPU_PendSVHandler AREA |.text|, CODE, READONLY, ALIGN=2 THUMB REQUIRE8 PRESERVE8 ; 保存中断状态并关中断 OS_CPU_SR_Save PROC MRS R0, PRIMASK ; 读取PRIMASK/BASEPRI（中断状态寄存器）并存⼊R0 CPSID I ; 关闭中断 BX LR ; 返回 ENDP ; 恢复中断状态 OS_CPU_SR_Restore PROC MSR PRIMASK, R0 ; 将R0的值写回PRIMASK/BASEPRI寄存器 BX LR ENDP ; 任务上下⽂切换，此处为空实现，仅供通过编译。以后需要实现任务上下⽂切换代码。 OSCtxSw PROC BX LR ENDP ; 中断级任务切换，空实现 OSIntCtxSw PROC BX LR ENDP ; 启动最⾼优先级任务，空实现，实际需要初始化任务堆栈并启动第⼀个任务 OSStartHighRdy PROC BX LR ENDP ; PendSV 中断处理，空实现，实际应实现PendSV中断处理以完成任务切换 OS_CPU_PendSVHandler PROC BX LR ENDP END 错误类型8：缺少main函数 解决方法：添加主函数\n1 .\\Objects\\test.axf: Error: L6218E: Undefined symbol main (referred from __rtentry2.o). 创建user文件夹，加入main.c文件：\n1 2 3 4 5 6 7 #include \u0026#34;ucos_ii.h\u0026#34; int main() { while(1) { } } 工程验证 想法1：调⽤函数 eg：OSTimeDly(1000 * 2);\n预期结果：编译通过且不报错，说明⼯程搭建成功。\n想法2：点亮⼩灯 由于任务创建点亮⼩灯需要例如创建tcb，堆栈⼤⼩优先级，队列，延时等知识，在后续的学习中我们才会学到。但我们仍想通过点亮⼩灯来验证⼯程搭建成功。\n因此我们的思路是：\n写⼀个led.c，通过上⾯我们提到的钩⼦函数调⽤led.c，再在main.c⾥⾯调⽤钩⼦函数，从⽽达到通过点亮⼩灯验证⼯程搭建是否成功。由于时间关系，我们直接来看我们写好的点灯程序。\n这⾥我们需要注意的是我们需要注释掉我们⾃⼰在cpu_c.h中写的空的SystemInt（）函数，因为在\nf401已经含有初始化系统的函数。\n预期结果：编译通过且不报错，板载⼩灯L2闪烁，说明⼯程搭建成功。\n项目总结 通过本项目，掌握了μC/OS-II内核重构的核心流程，解决了跨平台移植中的典型问题，为后续实现完整RTOS功能打下坚实基础。下一步将深入任务调度与硬件驱动集成，构建实时嵌入式应用。\n","date":"2025-03-07T17:52:26+08:00","permalink":"https://KiWiTChen.github.io/p/rtos%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%E4%B8%80keil%E9%87%8D%E6%9E%84%CE%BCcos_ii/","title":"RTOS学习小记（一）——Keil重构μCOS_II"},{"content":"创建工程 一个完整的PCB工程应该包含lib、schdoc、pcbdoc,在本节我们先学习绘制schlib即原理图。\n创建之后的文件目录参考：\n尽量避免直接打开上述单个文件，可以打开.PrjPcb项目文件\n元件符号 格点大小：\n一般管脚设置成100mil,图形元素格点为10mil\n简单元器件的绘制(自制原理图库) 原理图库只是实物器件在图纸上的表示，无需和实物尺寸一样\n电容(CAP) Designator:C?\nComment:容量\nDescription:其余描述\n电阻(RES) Designator:R?\nComment:容量\nDescription:其余描述\nAdd footprint:添加封装\n右侧Properties中设置各类参数：\n二极管(DIO) 发光二极管LED\nDesignator:D?\n绘制特殊图形如圆形、多边形。\n通过line shape，可以设置为箭头形式，同理可以在line设置其颜色等。\n之后按住shift拖动，可以复制箭头图像。\nA表示正极，一般不显示；同理K表示负极。\n运放 具体器件具体命名\n将+、-移动到三角形内部。\n一个器件可以有多个part\n![](index.assets/屏幕截图 2024-09-20 205411.png)\n原理图库的调用 其他库中调用 在他人的原理图库中，可以调用元器件 复制后粘贴到自己的SCH Library\n导入外部库 .intlib\n集成库，既有原理图库，也有封装\n.schlib\n仅原理图库\n.pcblib\n仅封装库\n一般来说，AD软件下载安装后会自带两个库，但是不能满足我们的需求，比如在绘制STM32F4系列时，我们需要用到F4的库，网上找了很多，但是直接导入.intlib最为省事，这里给出了github上的一个文件：[下载地址](https://github.com/ryankurte/altium-library/blob/master/third_party/STMicroelectronics STM32 F4.IntLib)\n总结：\n原理图库的正确性检查 勾选后自动检查并生成报告\n可能的报错类型:\n原理图的绘制 这里我们以STM32F401RET6为例，尝试简单绘制一下原理图\n页面调整 双击原理图边缘进入属性面板，可调整纸张尺寸，网格大小，隐藏表头和边框\n设计(D) -\u0026gt; 模板(T) -\u0026gt; 本地(L) 可调用官方的原理图预设模板\n芯片绘制 在DataSheet-f401re手册中，我们找到芯片的引脚描述\nUFQFPN48、LQFP64、LQFP100是集成电路的不同封装类型，其中我们使用的属于LQFP64封装\n再在.schlib中绘制芯片并放置引脚，右上角properities\u0026ndash;\u0026gt;pins可以统一设置引脚名称、编号以及参数。\n芯片引脚分类以及“最小系统” 电源——(VBAT)(VDD,VSS)(VDDA,VSSA)(VREF+,VREF-)等\n晶振IO——主晶振IO，RTC晶振IO\n下载IO——用于JTAG下载的IO：JTMS，JTCK，JTDI，JTDO，NJTRST\nBOOT IO——BOOT0，BOOT1，用于设置系统的启动方式\n复位IO——NRST，用于外部复位\nGPIO——通用输入输出\n前五部分IO组成的系统叫做最小系统\n接线与网络标签 为了使连线更加简洁，不易交错，一般采用网络标签\n两个相同名称的网络标签默认连接端口，离图连接器等网络标识符可以可表示图之间的网络连接\n![](index.assets/屏幕截图 2024-10-14 111145.png)\n（按住Alt，鼠标单击某个网络标签，就能看到相同的网络标签对应高亮显示）\n整体修改编号 全部元件放入后可整体编号，使每个元件都有标号且不冲突即可\n工具(T) -\u0026gt; 标注(A) -\u0026gt; 原理图标注(A）\n划分区块 为了使原理图简便易读，可以用线条将其划分成多个模块，后续设计PCB图时也能有帮助。\n封装统一管理 工具(T) -\u0026gt; 封装管理器(G) ，可统一添加封装。\n接收变化 -\u0026gt; 验证变更 -\u0026gt; 执行变更\n编译原理图 工程右键-\u0026gt;工程选项(O) 可查看原理图规则设置\n集中检查以下对象，可将其配置为错误(只有警告视为编译通过，不会报错)\nFloating net labels 悬浮的网络标签\nFloating power objects 悬浮的电源端口\nNets with multiple names 重复的网络标签\nNets with only one pin 单端网络\nUn-Designated parts requiring annotation 需要注释的未指定文件\nDuplicate Part Designators 重复的元件位号\n项目(C) -\u0026gt;Validate PCB Project，编译原理图，原理图设计不合理处(走线悬空，元件之间堆叠等)，会出\n现报错，可根据软件的报错信息定位报错位置，做出相应的修改。\n原理图打印 文件(F) -\u0026gt; 智能PDF(M) 进入PDF创建下载\n选择输出文档范围，是否对BOM表(物料清单)进行输出，参数设置\n","date":"2024-10-22T22:32:37+08:00","permalink":"https://KiWiTChen.github.io/p/stm32%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%E4%BA%8C%E5%BA%94%E7%94%A8ad%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%E5%9B%BE/","title":"Stm32学习小记（二）——应用AD绘制原理图"},{"content":"基本数据类型的转换 自动类型转换规则 精度小\u0026ndash;\u0026gt;精度大 ​ char\u0026ndash;\u0026gt;int\u0026ndash;\u0026gt;long\u0026ndash;\u0026gt;float\u0026ndash;\u0026gt;double\n​ byte\u0026ndash;\u0026gt;short\u0026ndash;\u0026gt;int\u0026ndash;\u0026gt;long\u0026ndash;\u0026gt;float\u0026ndash;\u0026gt;double\n​ 比如： int a=\u0026lsquo;c\u0026rsquo;//正确\nbyte,short和char不能自动转换，但是三者可以相互运算，先换为Int类型\n比如：\n1 2 3 4 5 byte a=126; byte b=1; short c=1; int d=a+c;//正确 byte e=a+b;//错误，只能是int 强制类型转换规则 使用时加上强制类型转换符() 细节 基本数据类型和String类型的转换 基本-\u0026gt;String:\n加上\u0026quot;\u0026ldquo;即可，如：\n1 2 3 4 5 6 7 int a=100; float b=10.1f; boolean c=true; String s1=a+\u0026#34;\u0026#34;; String s2=b+\u0026#34;\u0026#34;; String s3=c+\u0026#34;\u0026#34;; System.out.println(s1+\u0026#34;\u0026#34;+s2+\u0026#34;\u0026#34;+s3+\u0026#34;\u0026#34;);//10010.1true 需要注意的是，基本数据类型不一定在String中能找到对应，如hello就不能转换为int类型\nString-\u0026gt;基本\n调用parse xx方法即可\n1 2 3 String s=\u0026#34;1234\u0026#34;; int convert_s=Integer.parseInt(s);//1234 //double,float,long,byte,boolean,short等同理 怎样取出字符串的首字符？\nchar s_first=s.charAt(0);\nJAVA中的数组 使用细节 数组是多个相同数据类型的组合。 数组中可以放基本类型/引用类型，但是不能混用。 数组本身属于引用类型，数组型的数据本质上是对象。 赋值机制 值传递：对于基本数据类型（如int, float, char等），Java使用值传递。也就是说，当你将一个基本类型的变量作为参数传递给方法时，传递的是该变量的一个副本，方法内部对该副本的修改不会影响原变量。\n引用传递：对于引用类型（包括数组，对象等），Java使用引用传递。传递的是对象的引用（即对象在内存中的地址），而不是对象本身。这意味着在方法内部对对象的修改会影响到原对象。\n两者区别：\n引用重新赋值:虽然传递的是对象的引用，但如果在方法内部将这个引用重新指向另一个对象，那么这种更改不会影响原始引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Test { public static void main(String[] args) { int[] array = {1, 2, 3}; modifyArray(array); change(array); for (int i : array) { System.out.print(i + \u0026#34; \u0026#34;); // 输出：10 2 3 } } public static void modifyArray(int[] arr) { arr[0] = 10; // 修改数组的第一个元素 } public static void change(int[] arr){ arr = new int []{4,3,2,1}; } } //结果中数组array的第一个元素被改变。 //但是后面没变，因为change方法中new int 的数组只在其作用域内赋值，不会改变main方法的元素 ​\t数组在默认情况下是引用传递，赋的值是地址。\n​\t如：\n1 2 3 4 int [] arr1 ={1,2,3}; int [] arr2 =arr1; arr2[0] = 10; //arr1的值因arr2的改变而改变 ","date":"2024-09-27T20:02:00+08:00","permalink":"https://KiWiTChen.github.io/p/java%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84/","title":"Java学习小记（一） ——数据类型与数组"},{"content":"[TOC]\nMPU6050介绍 MPU6050简介 mpu6050是一款多轴传感器融合的运动处理模块，它具有一个嵌入式3轴MEMS陀螺仪，一个3轴MEMS加速度计以及一个DMP硬件加速引擎，通过I2C通信接口，mpu6050模块可将整合的加速度以及角加速度信息发送到终端MCU，供设备使用。这一特性使其广泛运用于手机、平板、游戏控制器、可穿戴式设备等领域。\n在江科大提供的模块资料中，我们可以找到product specification和register map手册，但是英文版手册难以阅读，这时可以使用翻译网站DeepL翻译：全世界最准确的翻译进行pdf、word等格式手册的自动翻译，使用效果还是非常不错的。\n硬件电路及引脚定义 I2C通信SCL、SDA：引脚23、24，内置了4.7k的两个上拉电阻。 电源引脚VDD、GND：引脚13、18。 主机I2C引脚XCL、XDA：额外的I2C通信引脚，连接外部磁力传感器，可通过DMP向应用输出完整的9轴融合演算数据。 地址AD0引脚：设置通信中的从机地址，若引脚不接（接地状态）则地址为0x68；若接入高电平，则为0x69。 中断引脚INT：通过设置相应寄存器，可以实现中断的配置。 数据采集和传输原理 $$ \\mid 使能前的值-使能后的值\\mid\u003c\\Delta c $$ 之后陀螺仪和角加速度计采集数据，经过ADC模数转换器处理后传到sensor registers，结合DMP可对相应数据解算，得到MPU6050的姿态信息。\nI2C通信协议 通讯特点 两根通信线：SCL(serial clock)和SDA(serial data)，通过英文定义我们大概可以知道SCL对应时钟，SDA则与数据传输相关。\n同步：同步时序需要一根时钟线指导数据读写，因此它可以支持读写过程中的暂停，对硬件电路的依赖程度比较低；与之对应的异步时序则不需要时钟线，节省了部分资源，但是它对数据传输的速率和时间都有十分严格的要求，依赖硬件电路的支持。\n半双工：发送和接收数据共用一根线（SDA），可双向传输；而全双工需要发送和接收两条线，单工则只能单向传输。\n总线可接入多设备：一主多从、多主多从。\n应用：广泛应用于MPU6050、OLED、AT24CO2等电子模块。\nI2C时序 基本单元 发送一个字节：发送字节时，SCL、SDA全程由主机控制。低电平时主机放数据，高电平时从机读数据。\n接收一个字节：低电平时从机放数据，高电平时主机读数据。\n发送应答与接收应答：主机接收后发送；主机发送后接收。\n时序实例 指定地址写\n当前地址读\n指定地址读（复合而成）\n软件I2C实现MPU6050数据读写 前面我们提到MPU6050使用的是I2C通信协议，那么就需要找到SCL和SDA引脚，查找STM32F103C8T6引脚定义图可以知道这两个GPIO口分别为PB10、PB11。\nMPU5060寄存器配置 采样频率分频器SMPRT_DIV 主要与数据刷新的快慢相关，\n本次实验以陀螺仪晶振为例，不使用8KHz外部晶振，使用1kHz的晶振，故需启用DLPF。\n配置寄存器CONFIG 主要考虑低通滤波器设置部分，即下图的0-2位。\n陀螺仪配置寄存器GYRO_CONFIG 第5-7位控制陀螺仪的自检（self test）；第3、4位控制满量程的选择，满量程可以根据实际使用进行调节，使得实验数据更加精确。\n类似于高中电路实验电表的选择？\n加速度计配置寄存器ACCEL_CONFIG 大致与陀螺仪配置寄存器相同，但是0-1位还可以用来配置高通滤波。\n数据寄存器（加速度、陀螺仪、温度计等） ​\t这几个寄存器类型为只读，可以读取加速度、角加速度、温度等原始信息。\n库函数代码配置 SCL、SDA的读写函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //SCL写入 void MyI2C_W_SCL(uint8_t Bitvalue) { GPIO_WriteBit(GPIOB,GPIO_Pin_10,(BitAction)Bitvalue); Delay_us(10); } //SDA写入 void MyI2C_W_SDA(uint8_t Bitvalue) { GPIO_WriteBit(GPIOB,GPIO_Pin_11,(BitAction)Bitvalue); Delay_us(10); } //SDA读取 uint8_t MyI2C_R_SDA(void) { uint8_t Bitvalue; Bitvalue=GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_11); Delay_us(10); return Bitvalue; } 起始和终止函数 在SCL、SDA读写函数完成后，可以配置I2C通信协议的起止函数驱动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void MyI2C_Start(void) { MyI2C_W_SDA(1); MyI2C_W_SCL(1); MyI2C_W_SDA(0);//先拉低SDA，后SCL. MyI2C_W_SCL(0); } void MyI2C_Stop(void) { MyI2C_W_SDA(0); MyI2C_W_SCL(1); MyI2C_W_SDA(1); } 在开始时先把SCL和SDA都拉高（置1）。考虑到结束时SDA数据并不总是低电平，为重复起始条件，需手动把SDA线先拉低到低电平，再操作SCL线；同样地，终止时SDA不总是低电平，需先将SDA拉低，再将其拉高完成终止操作。\n简单来说就是，在SCL时钟线高电平的期间，SDA数据线不能有任何电平的翻转，若SCL时钟线高电平的期间SDA从低电平拉到高电平则重复开始，从高电平拉到低电平则会认为此时发送数据已结束。\nI2C发送与接收数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //发送8字节 void MyI2C_SendByte(uint8_t Byte) { uint8_t i; for (i = 0; i \u0026lt; 8; i ++) { MyI2C_W_SDA(Byte \u0026amp; (0x80 \u0026gt;\u0026gt; i)); MyI2C_W_SCL(1); MyI2C_W_SCL(0); } } //接收部分 uint8_t MyI2C_ReceiveByte(void) { uint8_t i, Byte = 0x00; MyI2C_W_SDA(1);//释放SDA for (i = 0; i \u0026lt; 8; i ++) { MyI2C_W_SCL(1); if (MyI2C_R_SDA() == 1){Byte |= (0x80 \u0026gt;\u0026gt; i);} MyI2C_W_SCL(0); } return Byte; } 发送数据时高位先行，发送结束后SCL置低电平；接收数据时同样是高位先行，接收结束后SCL置0。\n发送与接收应答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void MyI2C_SendAck(uint8_t AckBit) { MyI2C_W_SDA(AckBit); MyI2C_W_SCL(1); MyI2C_W_SCL(0); } uint8_t MyI2C_ReceiveAck(void) { uint8_t AckBit; MyI2C_W_SDA(1); MyI2C_W_SCL(1); AckBit = MyI2C_R_SDA(); MyI2C_W_SCL(0); return AckBit; } 主机在接收完一个字节之后，在下一个时钟发送一位数据，数据0表示应答，数据1表示非应答；发送完一个字节之后，在下一个时钟接收一位数据，判断从机是否应答，数据0表示应答，数据1表示非应答（主机在接收之前，需要释放SDA）。\n读写MPU6050的寄存器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //写寄存器 void MPU6050_WriteReg(uint8_t RegAddress,uint8_t Data) { MyI2C_Start(); MyI2C_SendByte(MPU6050_ADDRESS); MyI2C_ReceiveAck(); MyI2C_SendByte(RegAddress); MyI2C_ReceiveAck(); MyI2C_SendByte(Data); MyI2C_ReceiveAck(); MyI2C_Stop(); } //读寄存器 uint8_t MPU6050_ReadReg(uint8_t RegAddress) { uint8_t Data; MyI2C_Start(); MyI2C_SendByte(MPU6050_ADDRESS); MyI2C_ReceiveAck(); MyI2C_SendByte(RegAddress); MyI2C_ReceiveAck(); MyI2C_Start(); MyI2C_SendByte(MPU6050_ADDRESS | 0x01); MyI2C_ReceiveAck(); Data=MyI2C_ReceiveByte(); MyI2C_SendAck(1); MyI2C_Stop(); return Data; } 写寄存器的具体过程是：\n开始\n主机发送MPU6050地址\n收到应答位\n发送寄存器地址\n收到应答位\n发送数据\n收到应答位\n结束\n每发送一次数据，都要接收相应的应答位，之后继续发送或是停止。\n读寄存器过程大致相同，区别只是在于刚开始时要写一下MPU6050设备地址，相当于喊一下MPU6050，告知它我们要和它进行通讯了。\nMPU6050初始化 在完成了MPU6050读写寄存器函数的配置后，我们就可以开始对MPU6050进行初始化。\n需要写的寄存器有电源管理寄存器1、2，采样频率分频器，配置寄存器，陀螺仪配置寄存器，加速度配置寄存器。\n1 2 3 4 5 6 7 8 9 10 void MPU6050_Init(void) { MyI2C_Init(); MPU6050_WriteReg(MPU6050_PWR_MGMT_1,0x01); MPU6050_WriteReg(MPU6050_PWR_MGMT_2,0x00); MPU6050_WriteReg(MPU6050_SMPLRT_DIV,0x09); MPU6050_WriteReg(MPU6050_CONFIG,0x06); MPU6050_WriteReg(MPU6050_GYRO_CONFIG,0x18); MPU6050_WriteReg(MPU6050_ACCEL_CONFIG,0x18); } 读取MPU6050数据 通过读取前面所提到的数据寄存器，获取有符号的16位整型加速度、角加速度信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //也可指定一个基地址，读取连续一片地址 void MPU6050_GetData(int16_t *AccX, int16_t *AccY, int16_t *AccZ, int16_t *GyroX, int16_t *GyroY, int16_t *GyroZ) { uint8_t DataH, DataL; DataH = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_H); DataL = MPU6050_ReadReg(MPU6050_ACCEL_XOUT_L); *AccX = (DataH \u0026lt;\u0026lt; 8) | DataL; DataH = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_H); DataL = MPU6050_ReadReg(MPU6050_ACCEL_YOUT_L); *AccY = (DataH \u0026lt;\u0026lt; 8) | DataL; DataH = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_H); DataL = MPU6050_ReadReg(MPU6050_ACCEL_ZOUT_L); *AccZ = (DataH \u0026lt;\u0026lt; 8) | DataL; DataH = MPU6050_ReadReg(MPU6050_GYRO_XOUT_H); DataL = MPU6050_ReadReg(MPU6050_GYRO_XOUT_L); *GyroX = (DataH \u0026lt;\u0026lt; 8) | DataL; DataH = MPU6050_ReadReg(MPU6050_GYRO_YOUT_H); DataL = MPU6050_ReadReg(MPU6050_GYRO_YOUT_L); *GyroY = (DataH \u0026lt;\u0026lt; 8) | DataL; DataH = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_H); DataL = MPU6050_ReadReg(MPU6050_GYRO_ZOUT_L); *GyroZ = (DataH \u0026lt;\u0026lt; 8) | DataL; } 需要注意的是，获取器件ID号的部分函数是uint8_t的定义类型，需要单独封装。\n1 2 3 4 uint8_t MPU6050_GetID(void) { return MPU6050_ReadReg(MPU6050_WHO_AM_I); } 主函数编写 为了检验数据是否能正常采集，在OLED初始化过后，在主函数中调用MPU6050及相关函数，将数据显示到OLED显示屏上面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026#34;stm32f10x.h\u0026#34; #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;OLED.h\u0026#34; #include \u0026#34;MPU6050.h\u0026#34; uint8_t ID; int16_t AX, AY, AZ, GX, GY, GZ; //分层编写与测验代码 int main(void) { OLED_Init(); MPU6050_Init(); OLED_ShowString(1, 1, \u0026#34;ID:\u0026#34;); ID = MPU6050_GetID(); OLED_ShowHexNum(1, 4, ID, 2); while (1) { MPU6050_GetData(\u0026amp;AX, \u0026amp;AY, \u0026amp;AZ, \u0026amp;GX, \u0026amp;GY, \u0026amp;GZ); OLED_ShowSignedNum(2, 1, AX, 5); OLED_ShowSignedNum(3, 1, AY, 5); OLED_ShowSignedNum(4, 1, AZ, 5); OLED_ShowSignedNum(2, 8, GX, 5); OLED_ShowSignedNum(3, 8, GY, 5); OLED_ShowSignedNum(4, 8, GZ, 5); } } 具体效果如下图所示：\n读取数据经蓝牙发送 库函数实现USART串口初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void Serial_Init(void) { RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);//开启USART1的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//GPIOA时钟使能 GPIO_PinRemapConfig(GPIO_Remap_USART1,ENABLE);//添加部分，GPIO口复用 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;//复用推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOA, \u0026amp;GPIO_InitStructure); USART_InitTypeDef USART_InitStructure; USART_InitStructure.USART_BaudRate = 9600; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Tx;//仅配置接收TX USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_Init(USART1, \u0026amp;USART_InitStructure); USART_Cmd(USART1, ENABLE); } 由于蓝牙串口发送暂时不需要RX引脚（即PA10），上面部分代码仅配置了PA9引脚，字长为8字节，停止位1，无校验位。\n编写串口发送函数 通过查找相应库函数，可以完成发送一个字节的功能。\n串口发送的函数其实就是向DR寄存器写入数据，Data\u0026amp;(uint16_t)0x01FF实现DR寄存器无关的高位清零；实际发送时，TDR寄存器把数据一位一位地转到移位寄存器中，如果发送过快，可能会产生数据覆写等错误，为了避免产生，我们需要调用函数FlagStatus USART_GetFlagStatus获取标志位，直到TXE标志位置SET时停止循环。\n​\t1 2 3 4 5 6 //发送一个字节 void Serial_SendByte(uint8_t Byte) { USART_SendData(USART1, Byte); while (USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET);//再次写入时，标志位自动清零，所以不需要手动 } 这样就可以通过*Serial_SendByte()发送“+”和“-”以及封装发送数据的其他函数，后面r会用到。\nprintf函数的重定向 通过printf函数的重定向，我们可以实现printf打印输出串口数据，当然使用封装Serial_SendByte的Serial_SendString也可以达到目的。\n注意加上头文件include \u0026lt;stdio.h\u0026gt;。\n1 2 3 4 5 6 //对printf函数进行重定向，以使用printf int fputc(int ch, FILE *f) { Serial_SendByte(ch); return ch; } 封装MPU6050数据发送函数 之前我们已经实现了OLED显示屏上打印读取的ACC和GYRO数据，其中如何将一串有符号数字打印出来呢？\n可以参考一下以下库函数代码的思路：\n对于一个多位数12345，12345/10000%10=1，12345/1000%10=2，12345/100%10=3，12345/10%10=4，也就是说我们可以通过整除和取余相结合，一个一个地取出类似的多位数的每一位。\n下列OLED_Pow函数可以实现X的Y次方的计算，之后循环取出每一位就可以打印出数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //次方函数 uint32_t Serial_Pow(uint32_t X, uint32_t Y) { uint32_t Result = 1; while (Y --) { Result *= X;//X^Y } return Result; } //发送ACC、GYRO数据 void serial_print_MPU6050data(int32_t Number, uint8_t Length) { uint8_t i; uint32_t Number1; if (Number \u0026gt;= 0) { Serial_SendByte( \u0026#39;+\u0026#39;); Number1 = Number; } else { Serial_SendByte( \u0026#39;-\u0026#39;); Number1 = -Number; } for (i = 0; i \u0026lt; Length; i++)\t{ Serial_SendByte(Number1 / Serial_Pow(10, Length - i - 1) % 10 + \u0026#39;0\u0026#39;); //“/10”实现取左边，“%10”实现取右边；为了以字符形式一串行地显示，加上偏移\u0026#39;0\u0026#39; } printf(\u0026#34;\\r\\n\u0026#34;);//回车换行 } 主函数编写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int main(void) { MPU6050_Init(); Serial_Init(); while (1) { MPU6050_GetData(\u0026amp;AX, \u0026amp;AY, \u0026amp;AZ, \u0026amp;GX, \u0026amp;GY, \u0026amp;GZ); printf(\u0026#34;ACC:\\r\\n\u0026#34;); serial_print_MPU6050data(AX,6); serial_print_MPU6050data(AY,6); serial_print_MPU6050data(AZ,6); printf(\u0026#34;GYRO:\\r\\n\u0026#34;); serial_print_MPU6050data(GX,6); serial_print_MPU6050data(GY,6); serial_print_MPU6050data(GZ,6); Delay_ms(1000);//延时1秒 } } 最后在手机端蓝牙调试助手实现收发。\n","date":"2024-09-22T22:56:45+08:00","permalink":"https://KiWiTChen.github.io/p/stm32%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%E4%B8%80mpu6050%E6%A8%A1%E5%9D%97/","title":"Stm32学习小记（一）——MPU6050模块"}]